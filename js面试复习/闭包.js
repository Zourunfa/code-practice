/**
 * 闭包是那些能够访问到自由变量的函数
 * 
 * 自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量
 * 
 * 闭包 = 函数 + 函数能够访问的自由变量
 * 
 * 
 * 
 */


var a = 1

function foo() {
  console.log(a);
}

foo()

//  foo函数可以访问变量a,但既不是foo函数的局部变量，函数也不是foo的参数，所以a
//  就是自由变量
//  那么 函数foo+foo函数访问的自由变量a就构成了一个闭包，但是这只是理论上的闭包



/**
 * 实践上的闭包
 * 
 * 1,从理论角度：所有的函数。因为他们都在创建的时候就将上层上下文的数据保存起来了
 * 哪怕是简单的全局变量也是如此，因为函数中访问全局变量，就当是在访问自由变量，这个
 * 时候使用最外层作用域。
 * 2，从实践角度：以下函数才算是闭包：
 *    （1）即使创建它的上下文已经销毁，它依旧存在（比如：内部函数从父函数中返回）
 *     (2) 在代码中引用了自由变量
 * 
 * 
 * 看下面的例子
 */

var scope = "global scope"

function checkscope() {
  var scope = "local scope"
  function f() {
    return scope
  }
  return f
}

var foo = checkscope()
foo()

/**
 * 首先我们要分析一下这段代码中执行上下文栈和执行上下文的变化情况
 *
 * 1，进入全局代码，创建全局执行上下文，全局执行上下文进入执行上下文栈
 * 2，全局执行上下文初始化
 * 3，执行checkscope函数，创建checkscope函数执行上下文，checkscope执行上下文进入执行上下文栈
 * 4，执行checkscope函数，创建变量对象文，作用域链，this等
 * 5，checkscope函数执行完毕,checkscope执行上下从执行上下文栈中弹出
 * 6, 执行f函数，创建f函数执行上下文，f执行上下文被压入执行上下文栈
 * 7，f函数上下文初始化，创建变量对象，作用域链，this等
 * 8，f函数执行完毕，f函数上下文从执行上下文栈中弹出
 */

/**
 * 当f函数执行的时候,checkscope函数的上下文已经被销毁了（即从执行上下文栈中被弹出）
 * 怎么还会读取到checkscope作用域下的scope值了？
 *
 *
 */